(** Lowering.

    Main operations:
    - Closure conversion:
        - Transform `Fun` nodes into `MkClo` nodes
        - Distinguish parameter variables from environment variables.
        - Hoist all nested functions into top-level functions
    - Constant elimination:
        - All (large) constants are hoisted into a constant table on a per-function basis.
            - 'Large' means requiring more than one instruction to construct or physically
              occupying more than one value of space.
              This applies to:
                  - non-nullary constructors applied only to constants
                  - string literals

    The core entry point of this module is the function `program`, which lowers the body of every
    term declaration in a signature. (And throws away all type declarations.)

    See ../cloco.md
*)

open BasicSyntax

module I = Syntax.Internal
module L = Syntax.Low
module RawER = I.EnvRen
module ER = L.EnvRen
module PI = Pretty.Internal
module PL = Pretty.Low

(** Variables with indices beyond this value are free variables.
    Comparison of an internal syntax variable's index against the watermark determines whether the
    variable is a BVar or an EVar in the closed syntax. *)
type watermark = int

module CloBody = struct
    type key = int

    (* A description of a new, top-level function generated by closure conversion. *)
    type spec = {
        arity : arity;
        body : L.Term.t;
    }

    module Map = Util.StringMap

    type map = {
        map : spec Map.t;
        next : key;
    }

    let empty_map = {
        map = Map.empty;
        next = 0;
    }

    let add prefix spec m =
        let name = prefix ^ "_closure_" ^ string_of_int m.next in
        let new_map = { map = Map.add name spec m.map; next = m.next + 1 } in
        (name, new_map)

    let lookup name { map; _ } = Map.find_opt name map

    let remove name { map; next } = { map = Map.remove name map; next }

    let to_seq { map; _ } = Map.to_seq map
end

(* Lowering is stateful since its component transformations are as well:
    - Closure conversion requires state:
        - as we encounter variables, we update the current environment renaming to include them
        - as we encounter functions, we replace them with MkClo operations that refer to a
          synthetic name -- the _code_ of those functions is then stored in the state.
    - Constant elimination requires state:
        - as we encounter constants, we store them in a map, and give them IDs
 *)
module State = struct
    type t = {
        fns : CloBody.map;
        cts : Constant.map;
        theta : RawER.t;
    }

    let initial = {
        fns = CloBody.empty_map;
        cts = Constant.empty_map;
        theta = ER.empty;
    }
end

module Ctx = struct
    type t = {
        closure_prefix : string;
        watermark : watermark;
        info : ProgramInfo.t
    }
end

(** Originally called "Cloco" for closure conversion. Now this is responsible for the "lowering
    conversion", so it gets to be called the Loco monad. *)
module Loco = struct
    type 'a t = Ctx.t -> State.t -> State.t * 'a

    let bind (m : 'a t) (k : 'a -> 'b t) : 'b t =
        fun ctx s -> let (s', x) = m ctx s in k x ctx s'

    let (>=>) (f : 'a -> 'b t) (g : 'b -> 'c t) : 'a -> 'c t =
        fun x -> bind (f x) g

    let (>>) (m1 : 'a t) (m2 : 'b t) : 'b t =
        bind m1 (fun _ -> m2)

    let pure x = fun _ s -> (s, x)

    let modify f = fun _ s -> (f s, ())

    let rec traverse (f : 'a -> 'b t) (l : 'a list) : 'b list t = match l with
    | [] -> pure []
    | x :: xs ->
        bind (f x) @@ fun y ->
        bind (traverse f xs) @@ fun ys ->
        pure (y :: ys)

    (** Adds a new function to the current mapping, generating a new name for it. *)
    let add_function (d : CloBody.spec) : tm_name t = fun ctx s ->
        let (name, fns) = CloBody.add ctx.closure_prefix d s.fns in
        ({ s with fns } , name)

    (** Deletes a function from the current mapping, returning its description. *)
    let remove_function (f : tm_name) : CloBody.spec t = fun _ctx s ->
        match CloBody.lookup f s.fns with
        | None -> Util.invariant "[lower] any function to remove was already added"
        | Some d -> ({ s with fns = CloBody.remove f s.fns }, d)

    (** Adds a constant to the constant table, returning a fresh tag for it. *)
    let add_constant (c : Constant.spec) : Constant.tag t = fun _ctx s ->
        let tag, cts = Constant.add c s.cts in
        ({ s with cts }, tag)

    (** Gets the current watermark. *)
    let get_watermark : watermark t = fun ctx s -> (s, ctx.watermark)

    (** Performs the given action with the current watermark shadowed by the given value. *)
    let with_watermark (w : watermark) (m : 'a t) : 'a t =
        fun ctx s -> m { ctx with watermark = w } s

    (** Performs the given action with the watermark increased by the given value. *)
    let bumped_watermark (w : watermark) (m : 'a t) : 'a t =
        fun ctx s -> m { ctx with watermark = ctx.watermark + w } s

    let lookup_ctor c : ProgramInfo.ctor_spec t = fun ctx s ->
        (s, ProgramInfo.lookup_ctor c ctx.info)

    let lookup_ref f : ProgramInfo.ref_spec t = fun ctx s ->
        (s, ProgramInfo.lookup_ref f ctx.info)

    let get_env_ren : RawER.t t = fun _w s -> (s, s.theta)

    let put_env_ren (theta : RawER.t) : unit t = fun _ s -> { s with theta }, ()

    let with_ref_arity (f : tm_name) kind (n : arity) (m : 'a t) : 'a t = fun ctx s ->
        m { ctx with info = ProgramInfo.add_new_ref f (kind, n) ctx.info } s
end

(* Whenever we encounter a variable, we compare it to the current watermark.
   If it's less than the current watermark, the variable is a bound variable. Easy.
   If it's greater than the current watermark, the variable is free so we _subtract_ the current
   watermark from it to obtain an index that would make sense outside the current function.
   This adjusted index is then inserted into the current environment renaming.
   When we exit the current function, we have to examine the environment renaming that came out,
   since the indices stored inside it will then need to be reindexed. *)

(** Inserts an index into the current environment renaming.
    Returns the index _into the renaming_ of the given index. *)
let er_insert (i : index) : index Loco.t =
    let open Loco in
    bind get_env_ren @@ fun theta ->
    let (theta', j) = ER.insert i theta in
    bind (put_env_ren theta') @@ fun _ ->
    pure j

(** Closure-converts the index of a variable according to the active watermark, extending the
    current environment renaming in case the index refers to an environment variable. *)
let index (i : index) : L.var Loco.t =
    let open Loco in
    bind get_watermark @@ fun w ->
    if i < w then pure (`bound i) else
    bind (er_insert (i - w)) @@ fun j ->
    pure (`env j)

(** Closure-converts an environment renaming. Each index appearing in the given ER is reindexed
    according to the current watermark, updating the current (raw) environment renaming. *)
let env_ren (theta : RawER.t) : ER.t Loco.t = Loco.traverse index theta

(** Runs the given action with an empty environment renaming, reindexing the resulting environment
    renaming in the presence of the outer one after.
    Returns the reindexed environment renaming obtained from running the inner computation. *)
let er_pushed (m : 'a Loco.t) : (ER.t * 'a) Loco.t =
    let open Loco in
    bind get_env_ren @@ fun theta -> (* save outer ER *)
    bind (put_env_ren ER.empty) @@ fun _ -> (* flush active ER *)
    bind m @@ fun x -> (* run inner computation *)
    bind get_env_ren @@ fun theta' -> (* save inner ER *)
    bind (put_env_ren theta) @@ fun _ -> (* restore outer ER *)
    bind (env_ren theta') @@ fun theta' -> (* reindex saved inner ER *)
    pure (theta', x)

(* Closure-converts the head of an application according to a watermark, extending the given
   environment renaming in the case for a variable. *)
let head : I.Term.head -> L.Term.head Loco.t =
    let open Loco in function
    | I.Term.Var (_, i) ->
        bind (index i) @@ fun x -> pure (L.Term.Var x)
    | I.Term.Const (_, c) -> pure (L.Term.Const c)
    | I.Term.Ref (_, r) -> pure (L.Term.Ref r)
    | I.Term.Prim (_, p) -> pure (L.Term.Prim p)

let bump_of_rec_flag = function
    | Rec -> Loco.bumped_watermark 1
    | NonRec -> fun x -> x

let rec pattern : I.Term.pattern -> L.Term.pattern Loco.t = let open Loco in function
    | I.Term.LiteralPattern (_, l) -> pure @@ L.Term.LiteralPattern l
    | I.Term.WildcardPattern _ -> pure @@ L.Term.WildcardPattern
    | I.Term.VariablePattern (_, _) -> pure @@ L.Term.VariablePattern
    | I.Term.ConstPattern (_, c, ps) ->
        bind (lookup_ctor c) @@ fun ctor ->
        bind (traverse pattern ps) @@ fun ps ->
        pure @@ L.Term.ConstPattern (ctor.tag, ps)

(** Eta-expands an application of a head to account for a partial constructor or ref application.
    expand tH n tS requires:
        - n is the arity of tH
    Then n - |tS| is the number of abstractions that are generated. *)
let eta_expand tH n tS =
    (* idea: build a function like this:
            fun mk_app -> 'Fn x1 -> ... -> Fn xN -> `mk_app n` x1 ... xN'
        where mk_app will be constructed:
            - to perform a weakening by `n` on the spine tS that we didn't generate
            - to stitch the spine x1 ... xN onto the end of original spine *)
    let var i = I.Term.(App (fake_loc, Var (fake_loc, i), [])) in
    let fn t = I.Term.(Fun (fake_loc, (fake_loc, "!"), t)) in
    let add_fn mk_fns = fun body -> fn (mk_fns body) in
    let mk_app var_n tS_vars =
        if var_n = 0
        then I.Term.(App (fake_loc, tH, tS))
        else
            let tH' = I.Ren.(apply_head (shift var_n)) tH in
            let tS' = I.Ren.(apply_spine (shift var_n)) tS in
            I.Term.(App (fake_loc, tH', tS' @ tS_vars))
    in
    let rec go n k tS tS_vars mk_fns = match n, tS with
    (* run out of arity and spine: generate the eta-expanded application *)
    | 0, [] -> mk_fns (mk_app k tS_vars)
    (* spine but no arity: no eta-expansion possible (happens in higher-order situations) *)
    | 0, _t :: _tS -> mk_app 0 []
    (* arity but no spine: extend spine with a var and add an abstraction *)
    | n, [] -> go (n-1) (k+1) [] (var k :: tS_vars) (add_fn mk_fns)
    (* spine and arity: keep counting down *)
    | n, _t :: tS -> go (n-1) k tS [] mk_fns
    in
    go n 0 tS [] (fun body -> body)

(* For any head, decide what its arity is if possible. *)
let arity_of_head = let open Loco in function
    | I.Term.Var _ -> pure `unknown
    | I.Term.Const (_, c) -> bind (lookup_ctor c) @@ fun ctor -> pure @@ `known ctor.arity
    | I.Term.Ref (_, r) -> bind (lookup_ref r) @@ fun r -> pure @@ `known r.arity
    | I.Term.Prim (_, p) -> pure @@ `known (Prim.arity p)

let is_static_function : I.Term.t -> bool =
    function
    | I.Term.Fun _ -> true
    | _ -> false

let literal : literal -> Constant.ref Loco.t = let open Loco in function
    | IntLit n -> pure @@ `unboxed n
    | CharLit c ->
        let n = Int64.of_int @@ Char.code c in
        pure @@ `unboxed n
    | BoolLit b ->
        let n = if b then 1L else 0L in
        pure @@ `unboxed n
    | StringLit s ->
        bind (Loco.add_constant { constant = Constant.String s }) @@ fun tag ->
        pure @@ `boxed tag

type 'a or_constant = [ `dyn of 'a | `constant of Constant.ref ]

let to_term : L.Term.t or_constant -> L.Term.t = function
    | `dyn t -> t
    | `constant r -> L.Term.Constant r

(* Lowers a term while also converting it to a constant if possible. *)
let rec term : I.Term.t -> L.Term.t or_constant Loco.t =
    let open Loco in
    (* Lower a term that is KNOWN to be a function. *)
    let func e : L.Term.t or_constant Loco.t =
        let _xs, e, w' = I.Term.collapse_funs e in
        if w' = 0 then Util.invariant "[lower] [func] must be applied to a function";
        (* w': the count of funs is the watermark to use within the function body *)
        bind (er_pushed @@ with_watermark w' @@ term e) @@ fun (theta, e') ->
        bind (add_function { arity = w'; body = to_term e' }) @@ fun f ->
        pure @@ `dyn (L.Term.MkClo (theta, w', f))
    in
    (* Lower an application. *)
    let app tH tS =
        bind (head tH) @@ fun tH ->
        bind (spine tS) @@ fun tS ->
        match tH with
        (* check if all tS are constant to form a bigger constant *)
        | L.Term.Const _c -> failwith "todo: bigger constants from constructors"
        | _ -> pure @@ `dyn (L.Term.App (tH, List.map to_term tS))
    in
    function
    | I.Term.Lit (_, lit) ->
        bind (literal lit) @@ fun ct -> pure @@ `constant ct
    | I.Term.Fun _ as e -> func e
    | I.Term.Let (_, rec_flag, (_, _x), e1, e2) ->
        bind (bump_of_rec_flag rec_flag @@ term e1) @@ fun e1' ->
        bind (bumped_watermark 1 @@ term e2) @@ fun e2' ->
        pure @@ `dyn (L.Term.Let (rec_flag, to_term e1', to_term e2'))
    | I.Term.Match (_, e, cases) ->
        bind (term e) @@ fun e' ->
        bind (traverse case cases) @@ fun cases' ->
        pure @@ `dyn (L.Term.Match (to_term e', cases'))
    | I.Term.App (_loc, tH, tS) ->
        bind (arity_of_head tH) @@ function
        | `unknown -> app tH tS
        | `known n ->
            match eta_expand tH n tS with
            | I.Term.Fun _ as e' -> func e'
            | I.Term.App (_, tH, tS) -> app tH tS
            | _ -> Util.invariant "[eta_expand] outcome is always a Fun or App"

and case : I.Term.case -> L.Term.case Loco.t =
    let open Loco in function
    | I.Term.Case (_, p, e) ->
        let n = I.Term.count_pattern_vars p in
        bind (pattern p) @@ fun p ->
        bind (bumped_watermark n @@ term e) @@ fun e ->
        pure (L.Term.Case (p, n, to_term e))

and spine (tS : I.Term.spine) : L.Term.t or_constant list Loco.t = Loco.traverse term tS

let tm_decl : I.Term.t I.Decl.tm -> (ProgramInfo.decl_kind * L.Decl.tm) Loco.t =
    let open Loco in
    function
    | I.Decl.({ body = None; _ }) -> failwith "todo"
    | I.Decl.({ name; rec_flag; body = Some body; _ }) ->
        let kind =
            if is_static_function body
            then `func
            else `well_known
        in
        bind (with_ref_arity name kind 0 @@ bump_of_rec_flag rec_flag @@ term body) @@ fun x ->
        match to_term x with
        | L.Term.MkClo (theta, _, _) when not (ER.is_empty theta) ->
            Util.invariant "[lower] top-level closure is trivial"
        | L.Term.MkClo (_, n, f) ->
            bind (remove_function f) @@ fun { body; _ } ->
            pure @@ (
                `func,
                L.Decl.({
                    name;
                    body;
                    arity = n;
                })
            )

        | body ->
            (* Otherwise, the definition is considered to not (statically) define a
               function. *)
            pure @@ (
                `well_known,
                L.Decl.({
                    name;
                    body;
                    arity = 0;
                })
            )

let extend_refs_with_closure_bodies
        (clo_bodies : CloBody.map)
        (info : ProgramInfo.t)
        : ProgramInfo.t =
    CloBody.to_seq clo_bodies
    |> Seq.fold_left
        (fun info (f, d) ->
            ProgramInfo.add_new_ref f (`closure_body, d.CloBody.arity) info)
        info

(** Converts a list of functions emitted during closure conversion into a list of genuine function
    declarations. *)
let declare_closure_bodies (clo_bodies : CloBody.map) : L.Decl.tm list =
    CloBody.to_seq clo_bodies
    |> Seq.map begin function
        | (f, d : tm_name * CloBody.spec) -> L.Decl.({ name = f; body = d.body; arity = d.arity })
    end
    |> List.of_seq

let rec program : ProgramInfo.t ->  I.Decl.program -> ProgramInfo.t * L.Decl.program =
    fun info -> function
    | [] -> (info, [])
    | d :: ds -> match d with
        | I.Decl.(TpDecl _) -> program info ds
        | I.Decl.TmDecl d' ->
            let (final_state, (kind, d)) =
                tm_decl d' Ctx.({
                    watermark = 0;
                    closure_prefix = d'.I.Decl.name;
                    info;
                }) State.initial
            in
            (* it emits a list of functions (closure bodies) to hoist to the top level
               thru its final state *)
            let info, ds =
                program
                    (info
                    |> ProgramInfo.add_new_ref d.name (kind, d.arity)
                    |> extend_refs_with_closure_bodies final_state.fns)
                    ds
                (* also overwrite the definition for d.name to include an updated kind & arity
                   according to eta-expansion that might have happened *)
            in
            let closure_body_decls = declare_closure_bodies final_state.fns in
            (info, closure_body_decls @ d :: ds)
